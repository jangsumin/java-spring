## 오늘의 개인 공부

### Q1. Maven과 Gradle의 차이는?

일단, 두 도구가 필요한 이유에 대해 언급하자면 자바로 개발할 때 수많은 외부 라이브러리를 활용할 수 있는데, '효율'적으로 활용하기 위해서는 의존성 관리를 자동화 해주는 빌드 도구의 활용이 필수적이다.

일일이 의존성을 관리하기는 어렵기 때문에 대부분의 자바 프로젝트에서는 `Maven`이나 `Gradle`과 같은 빌드 도구를 사용하고 있다. 빌드 도구를 사용하면 라이브러리들을 자동으로 다운로드하고 빌드 과정에 포함시켜주기 때문에 개발 작업의 효율성을 크게 높일 수 있다.

Maven이 등장하기 전에 Ant라는 빌드 도구를 사용했는데, Ant는 빌드에 필요한 외부 라이브러리를 관리해주지 않았다. 반면, Maven은 `pom.xml`이라는 빌드 파일 형식으로 빌드 설정을 관리하고 외부 라이브러리를 자동으로 관리해준다.

> [!NOTE]
> Maven은 다양한 프로젝트를 빠르게 생성하기 위한 '아키 타입(archetype)'을 제공한다.

하지만, 이러한 Maven도 빌드 속도가 느리고 유연성이 부족하다는 단점이 있다. 이를 개선하고 보완하기 위해 나온 것이 바로 Gradle이다. Gradle은 JetBrains사가 개발한 오픈 소스 빌드 자동화 도구로 Apache Ant와 Apache Maven의 장점을 결합하여 만들어졌다.

Maven은 xml 기반의 빌드 파일을 사용하기 때문에 가독성이 떨어지지만 Gradle은 Groovy 기반 스크립트 방식을 사용하여 `build.gradle`이라는 빌드 파일을 만들기 때문에 가독성이 좋고, 또 스크립트를 통해 여러가지 상황에 적합한 빌드를 만들어 낼 수 있어 유연하다.

🍀이러한 유연성 덕분에 Gradle은 빌드 과정에서 병렬 처리와 캐싱을 활용하여 Maven보다 10배~100배까지 향상된 성능을 구현할 수 있다.🍀

### Q2. 왜 사람들은 이클립스보다 인텔리제이를 더 선호할까?

질문이 내 선호를 반영한 거 같긴 하다... 이클립스는 무료이고 여러 프로젝트를 동시에 관리할 수 있다는 강점이 있지만, 자바를 제외한 언어로는 개발이 어렵다. 인텔리제이는 직관적인 UI를 제공하고 다양한 FE & BE 프로젝트를 생성할 수 있다. 더구나, 스마트 코드 작성 기능을 제공하기 때문에 생산성을 대폭 높여주고 형상관리를 git으로 하고 있을 때 편리하다.

### Q3. pom.xml의 정확한 역할은?

Maven의 빌드 정보를 담고 있는 파일로, POM(Project Object Model)을 설정하는 부분이면서 프로젝트 내 빌드 옵션을 설정하는 부분이다. 협업할 때 버전을 통일하기에 편리하다.

- `<project>`: Maven의 XML 네임스페이스 지정
- `<modelVersion>`: Maven의 model version
- `<groupId>`: 그룹 ID 태그(프로젝트를 식별할 수 있는 고유한 이름인데 일반적으로 도메인을 거꾸로 해서 만든다.)
- `<artifactId>`: 아티팩트 ID 태그(버전이 없는 jar 파일의 이름으로, 보통 프로젝트의 이름으로 사용된다.)
- `<version>`: 버전명 태그
- `<packaging>`: 패키징 형식을 지정하는 태그
- `<name>`: 프로젝트의 이름
- `<url>`: Maven의 URL
- `<properties>`: 프로젝트 관련 속성
- `<parent>`: pom.xml의 상속에 관련된 태그
- `<dependencies>`: 프로젝트가 의존하는 라이브러리들의 정보

### Q4. 가비지 컬렉션의 역할과 원리

가비지 컬렉션(Garbage Collection, 이하 GC)은 자바의 메모리 관리 방법 중의 하나로 JVM의 Heap 영역에서 동적으로 할당했던 메모리 중 필요 없게 된 메모리 객체를 모아 주기적으로 제거하는 프로세스

C/C++ 언어에서는 이러한 가비지 컬렉션이 없어서 프로그래머가 수동으로 메모리 할당과 해제를 일일이 해줘야 했다.

계속해서 객체를 생성하는 비즈니스 로직이 있다고 가정하자. 이런 객체들이 메모리를 계속 점유하고 있다면 다른 코드를 실행하기 위한 메모리 자원은 지속적으로 줄어들기만 한다. 하지만, Java를 쓸 때 우리가 신경쓰지 않아도 되는 이유는 GC가 한 번 쓰이고 버려지는 객체들을 주기적으로 비우고 메모리를 효율적으로 사용할 수 있게 해주기 때문이다.

물론 자바 뿐만 아니라, 파이썬, 자바스크립트, GO 등 많은 프로그래밍 언어에 기본으로 내장되어 있다.

단! 이런 만능 같은 GC에도 단점이 존재한다. 자동으로 처리해준다고 해도 메모리가 언제 해제되는지 정확하게 알 수 없어서 제어하기 힘들고 GC가 동작하는 동안에는 다른 동작을 멈추기 때문에 오버헤드가 발생한다.

STW(Stop The World) : GC를 수행하기 위해 JVM이 프로그램 실행을 멈추는 현상을 의미한다. GC 관련 스레드를 제외한 모든 스레드는 멈추게 되어 서비스 이용에 차질이 생길 수 있다.

객체에 레퍼런스가 있다면 Reachable로 구분하고, 유효한 레퍼런스가 없다면 Unreachable로 구분해버리고 수거한다. 객체는 실질적으로 힙 영역에 생성되고 Method Area나 Stack Area에서는 힙 영역에 생성된 객체의 주소만 참조하는 형식으로 구성된다.

Mark & Sweep
Mark : 루트 영역부터 그래프 순회를 통해 연결된 객체들을 찾아내어 각각 어떤 객체를 참조하고 있는지 찾아서 마킹한다.
Sweep : 참조하고 있지 않은 Unreachable 객체들을 힙에서 제거한다.
Compact : Sweep 후에 분산된 객체들을 힙의 시작 주소로 모아 메모리가 할당된 부분과 그렇지 않은 부분으로 나눈다.(GC의 종류에 따라 안할 수도 있다.)
